<html><head><meta content="text/html; charset=UTF-8" http-equiv="content-type"><st</head><body class="c44 c47"><h1 class="c22 c18" id="h.sl8q8y4gq0tb"><span class="c14">CarND-Path-Planning-Project</span></h1><h1 class="c18 c22" id="h.3gc3ewas5i1j"><span class="c14">Semantic Segmentation</span></h1><h3 class="c7" id="h.ihhrvp3uctp9"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 576.00px; height: 160.00px;"><img alt="" src="images/image9.png" style="width: 576.00px; height: 160.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></h3><h2 class="c7" id="h.8k1oepb1840z"><span class="c19">Introduction</span></h2><p class="c10"><span>The purpose of this project to segment road lanes by implementing correctly image segmentation </span><span class="c9">Fully Convolutional Network (FCN) </span><span>as specified in the </span><span class="c23"><a class="c8" href="https://www.google.com/url?q=https://people.eecs.berkeley.edu/~jonlong/long_shelhamer_fcn.pdf&amp;sa=D&amp;ust=1522472818100000">Fully Convolutional Networks for Semantic Segmentation</a></span><span class="c12">&nbsp;paper. </span></p><h2 class="c18 c38" id="h.geqv5l3926o4"><span class="c19">Summary </span></h2><ul class="c50 lst-kix_vx89dbfa2t45-0 start"><li class="c5 c55"><span class="c12">In this projects I I loaded VGG16 pretrained model and finetune VGG model to do lane segmentation to human-level accuracy. </span></li><li class="c5 c55"><span class="c12">Correctly combined new layers with VGG16 to construct your model.</span></li><li class="c5 c55"><span>Skip connections are used from previous vgg_layer3_out and vgg_layer4_out layers. The authors of </span><span class="c23"><a class="c8" href="https://www.google.com/url?q=https://people.eecs.berkeley.edu/~jonlong/long_shelhamer_fcn.pdf&amp;sa=D&amp;ust=1522472818101000">original paper</a></span><span class="c12">&nbsp;highly suggest to use these skip connections to improve segmentation accuracy.</span></li><li class="c5 c55"><span class="c12">Correctly added Deconvolution or Transpose Strided layers on top of provided VGG model.</span></li><li class="c5 c55"><span class="c12">Optimized graph parameters and train </span></li></ul><p class="c37"><span class="c30 c64"></span></p><h2 class="c24" id="h.cdrdlyjkurgu"><span class="c19">Below is a visualization of the projects architecture: </span></h2><p class="c61"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 780.00px; height: 464.00px;"><img alt="" src="images/image11.png" style="width: 780.00px; height: 464.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><h3 class="c7" id="h.ch0qbzojsdsi"><span class="c53">Setup</span></h3><h3 class="c7" id="h.kmmkbog2bz1y"><span class="c3">Frameworks and Packages</span></h3><p class="c10"><span class="c30 c9">Make sure you have the following is installed:</span></p><ul class="c50 lst-kix_1rj01lbgs74w-0 start"><li class="c10 c56"><span class="c29"><a class="c8" href="https://www.google.com/url?q=https://www.python.org/&amp;sa=D&amp;ust=1522472818103000">Python 3</a></span></li><li class="c4"><span class="c29"><a class="c8" href="https://www.google.com/url?q=https://www.tensorflow.org/&amp;sa=D&amp;ust=1522472818103000">TensorFlow</a></span></li><li class="c4"><span class="c29"><a class="c8" href="https://www.google.com/url?q=http://www.numpy.org/&amp;sa=D&amp;ust=1522472818103000">NumPy</a></span></li><li class="c4"><span class="c29"><a class="c8" href="https://www.google.com/url?q=https://www.scipy.org/&amp;sa=D&amp;ust=1522472818104000">SciPy</a></span></li></ul><h3 class="c7" id="h.h67a7u9i51oy"><span class="c3">Dataset</span></h3><p class="c10"><span class="c9">Download the </span><span class="c49"><a class="c8" href="https://www.google.com/url?q=http://www.cvlibs.net/datasets/kitti/eval_road.php&amp;sa=D&amp;ust=1522472818104000">Kitti Road dataset</a></span><span class="c9">&nbsp;from </span><span class="c49"><a class="c8" href="https://www.google.com/url?q=http://www.cvlibs.net/download.php?file%3Ddata_road.zip&amp;sa=D&amp;ust=1522472818104000">here</a></span><span class="c9">. Extract the dataset in the </span><span class="c63">data</span><span class="c9">&nbsp;folder. This will create the folder </span><span class="c63">data_road</span><span class="c9 c30">&nbsp;with all the training a test images.</span></p><h2 class="c7" id="h.hu03jrh0lj2d"><span class="c58">Run</span></h2><p class="c10"><span class="c30 c9">Run the following command to run the project:</span></p><p class="c18 c46"><span class="c34">python main.py</span></p><p class="c5"><span>To run this code you would need a GPU with at least 6GB of memory, because I did not have one with me I used </span><span class="c23"><a class="c8" href="https://www.google.com/url?q=http://www.floydhub.com&amp;sa=D&amp;ust=1522472818106000">floyhub</a></span><span class="c12">.</span></p><p class="c5 c40"><span class="c12"></span></p><p class="c5"><span class="c12">To run the project under floydhub type this line in your command line after you upload your data road dataset and vgg model:</span></p><p class="c5 c40"><span class="c12"></span></p><p class="c5"><span class="c12">floyd run --gpu --env tensorflow-1.3 --data USERNAME/datasets/data_road/1:/data_road</span></p><p class="c5"><span class="c12">--data USERNAME/datasets/pretrained_vgg/1:/pretrained_vgg &quot;python main.py&quot;</span></p><p class="c46 c18 c40"><span class="c34"></span></p><h3 class="c18 c27" id="h.cmmowlzhwcy8"><span class="c62">Project walk through:</span></h3><ol class="c50 lst-kix_b7drba6x2oxi-0 start" start="1"><li class="c25 c55"><h3 id="h.8nd9kbk7z486" style="display:inline"><span class="c3">Load the pretrained vgg model</span></h3></li></ol><p class="c5 c18"><span>F</span><span class="c12">unction load_vgg is implemented correctly to load (see main.py ln54). It loads the model VGG from a SavedModel as specified by &nbsp;tags &lsquo;vgg16&rsquo; and it saves it in the specified path vgg_path and with tf.get_default_graph() we get the graph with the loaded context.</span></p><p class="c0"><span class="c12"></span></p><a id="t.07784d1a38f72da83207b77d2dcfb0b6fd063d4c"></a><a id="t.0"></a><table class="c52 c18"><tbody><tr class="c36"><td class="c67" colspan="1" rowspan="1"><p class="c5 c18"><span class="c16">tf.saved_model.loader.load(sess</span><span class="c11">, </span><span class="c16">[</span><span class="c17">&#39;vgg16&#39;</span><span class="c16">]</span><span class="c11">, </span><span class="c2">vgg_path)</span></p><p class="c5 c18"><span class="c2">graph = tf.get_default_graph()</span></p><p class="c0"><span class="c2"></span></p><p class="c5 c18"><span class="c16">image_input = graph.get_tensor_by_name(</span><span class="c17">&#39;image_input:0&#39;</span><span class="c2">)</span></p><p class="c5 c18"><span class="c16">keep_prob = graph.get_tensor_by_name(</span><span class="c17">&#39;keep_prob:0&#39;</span><span class="c2">)</span></p><p class="c5 c18"><span class="c16">layer3_out = graph.get_tensor_by_name(</span><span class="c17">&#39;layer3_out:0&#39;</span><span class="c2">)</span></p><p class="c5 c18"><span class="c16">layer4_out = graph.get_tensor_by_name(</span><span class="c17">&#39;layer4_out:0&#39;</span><span class="c2">)</span></p><p class="c5 c18"><span class="c16">layer7_out = graph.get_tensor_by_name(</span><span class="c17">&#39;layer7_out:0&#39;</span><span class="c16">)</span></p></td></tr></tbody></table><p class="c5 c40"><span class="c12"></span></p><h2 class="c24" id="h.ohi920t1fxhj"><span class="c19">2. The function layers is implementation </span></h2><p class="c5"><span>The authors of </span><span class="c23"><a class="c8" href="https://www.google.com/url?q=https://people.eecs.berkeley.edu/~jonlong/long_shelhamer_fcn.pdf&amp;sa=D&amp;ust=1522472818111000">original paper</a></span><span class="c12">&nbsp;highly suggest to use these skip connections to improve segmentation accuracy.</span></p><p class="c5"><span class="c12">The original FCN-8s was trained in stages. The authors later uploaded a version that was trained all at once to their GitHub repo. The version in the GitHub repo has one important difference: The outputs of pooling layers 3 and 4 are scaled before they are fed into the 1x1 convolutions. As a result, some people have found that the model learns much better with the scaling layers included. The model may not converge substantially faster, but may reach a higher IoU and accuracy.</span></p><p class="c5 c40"><span class="c12"></span></p><p class="c5"><span>The function layers is implementation (see main.py ln78) as specified in the </span><span class="c23"><a class="c8" href="https://www.google.com/url?q=https://people.eecs.berkeley.edu/~jonlong/long_shelhamer_fcn.pdf&amp;sa=D&amp;ust=1522472818112000">Fully Convolutional Networks for Semantic Segmentation</a></span><span class="c12">. In order for weights to be transposed convolution layers &nbsp;are implemented using tf.layers.conv2d. After a transpose layer I applied a skip technique by adding to the output of the upper layer. The purpose of the transpose layer to match upper layer shape so I can merge weights using tf.add. </span></p><a id="t.eed9f02870b85317a8244927041917418a942c06"></a><a id="t.1"></a><table class="c18 c52"><tbody><tr class="c36"><td class="c65" colspan="1" rowspan="1"><p class="c5 c18"><span class="c16">kernel_initializer = tf.truncated_normal_initializer(</span><span class="c13">stddev</span><span class="c16">=</span><span class="c35">self</span><span class="c16">.init_sd)</span></p><p class="c5 c18"><span class="c20"># 1x1 convolutions of the three layers</span></p><p class="c5 c18"><span class="c16">conv_7 = tf.layers.conv2d(vgg_layer7_out</span><span class="c11">, </span><span class="c16">num_classes</span><span class="c11">, </span><span class="c33">1</span><span class="c11">, </span><span class="c33">1</span><span class="c11">, &nbsp;</span><span class="c13">kernel_initializer</span><span class="c16">=kernel_initializer</span><span class="c11">, </span><span class="c13">kernel_regularizer</span><span class="c2">=kernel_regularizer)</span></p><p class="c5 c18"><span class="c16">conv_4 = tf.layers.conv2d(vgg_layer4_out</span><span class="c11">, </span><span class="c16">num_classes</span><span class="c11">, </span><span class="c33">1</span><span class="c11">, </span><span class="c33">1</span><span class="c30 c11">,</span></p><p class="c5 c18"><span class="c11">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c13">kernel_initializer</span><span class="c16">=kernel_initializer</span><span class="c11">, </span><span class="c13">kernel_regularizer</span><span class="c2">=kernel_regularizer)</span></p><p class="c5 c18"><span class="c16">conv_3 = tf.layers.conv2d(vgg_layer3_out</span><span class="c11">, </span><span class="c16">num_classes</span><span class="c11">, </span><span class="c33">1</span><span class="c11">, </span><span class="c33">1</span><span class="c30 c11">,</span></p><p class="c5 c18"><span class="c11">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c13">kernel_initializer</span><span class="c16">=kernel_initializer</span><span class="c11">, </span><span class="c13">kernel_regularizer</span><span class="c2">=kernel_regularizer)</span></p><p class="c0"><span class="c2"></span></p><p class="c5"><span class="c42">&nbsp;</span><span class="c30 c42"># Upsample layer 7 and add to layer 4</span></p><p class="c5 c18"><span class="c20"># tf.layers.conv2d_transpose(inputs,filters,kernel_size,strides=(1, 1), padding=&#39;valid&#39;...)</span></p><p class="c5 c18"><span class="c16">input = tf.layers.conv2d_transpose(conv_7</span><span class="c11">, </span><span class="c16">num_classes</span><span class="c11">, </span><span class="c33">4</span><span class="c11">, </span><span class="c33">2</span><span class="c11">, </span><span class="c17">&#39;SAME&#39;</span><span class="c30 c11">,</span></p><p class="c5 c18"><span class="c11">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c13">kernel_initializer</span><span class="c16">=kernel_initializer</span><span class="c11">, </span><span class="c13">kernel_regularizer</span><span class="c2">=kernel_regularizer)</span></p><p class="c5 c18"><span class="c16">input = tf.add(input</span><span class="c11">, </span><span class="c2">conv_4)</span></p><p class="c0"><span class="c2"></span></p><p class="c5 c18"><span class="c20"># add to layer 3</span></p><p class="c5 c18"><span class="c16">input = tf.layers.conv2d_transpose(input</span><span class="c11">, </span><span class="c16">num_classes</span><span class="c11">, </span><span class="c33">4</span><span class="c11">, </span><span class="c33">2</span><span class="c11">, </span><span class="c17">&#39;SAME&#39;</span><span class="c30 c11">,</span></p><p class="c5 c18"><span class="c11">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c13">kernel_initializer</span><span class="c16">=kernel_initializer</span><span class="c11">, </span><span class="c13">kernel_regularizer</span><span class="c2">=kernel_regularizer)</span></p><p class="c5 c18"><span class="c16">input = tf.add(input</span><span class="c11">, </span><span class="c2">conv_3)</span></p><p class="c0"><span class="c2"></span></p><p class="c5 c18"><span class="c20"># Upsample the input and return</span></p><p class="c5 c18"><span class="c16">input = tf.layers.conv2d_transpose(input</span><span class="c11">, </span><span class="c16">num_classes</span><span class="c11">, </span><span class="c33">16</span><span class="c11">, </span><span class="c33">8</span><span class="c11">, </span><span class="c17">&#39;SAME&#39;</span><span class="c30 c11">,</span></p><p class="c5 c18"><span class="c11">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c13">kernel_initializer</span><span class="c16">=kernel_initializer</span><span class="c11">, </span><span class="c13">kernel_regularizer</span><span class="c16">=kernel_regularizer)</span></p></td></tr><tr class="c36"><td class="c65" colspan="1" rowspan="1"><p class="c5 c40"><span class="c2"></span></p></td></tr></tbody></table><p class="c0"><span class="c12"></span></p><p class="c0"><span class="c2"></span></p><p class="c5"><span class="c12">To smooth out on the edges pixels I ran a series of test with kernel_regularizer and &nbsp;kernel_initializer. And as you can see in the images bellow kernel_regularizer did slightly better. </span></p><p class="c5 c40"><span class="c2"></span></p><a id="t.e95b87504afaff215cb1e04a22cfcd5c6b8efa64"></a><a id="t.2"></a><table class="c52 c71"><tbody><tr class="c51"><td class="c59" colspan="2" rowspan="1"><p class="c15"><span class="c12">The following images were taking at 30 epoch just to identified a good way to smooth pixel on the edges. The real training model was trained with 100 epochs </span></p></td></tr><tr class="c36"><td class="c54" colspan="1" rowspan="1"><p class="c15"><span class="c12">With regularizer, no kernel_initialize</span></p></td><td class="c48" colspan="1" rowspan="1"><p class="c15"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 525.56px; height: 146.50px;"><img alt="" src="images/image8.png" style="width: 525.56px; height: 146.50px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p></td></tr><tr class="c6"><td class="c54" colspan="1" rowspan="1"><p class="c15"><span>With regularizer and kernel_initializer </span><span class="c70">vector norms</span><span class="c12">. </span></p></td><td class="c48" colspan="1" rowspan="1"><p class="c41 c18"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 513.00px; height: 142.67px;"><img alt="" src="images/image6.png" style="width: 513.00px; height: 142.67px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p></td></tr><tr class="c6"><td class="c54" colspan="1" rowspan="1"><p class="c15"><span>With kernel_initialize with </span><span class="c70">vector norms</span><span class="c12">, no regularizer</span></p></td><td class="c48" colspan="1" rowspan="1"><p class="c18 c41"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 513.00px; height: 142.67px;"><img alt="" src="images/image5.png" style="width: 513.00px; height: 142.67px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p></td></tr></tbody></table><p class="c0"><span class="c2"></span></p><p class="c0"><span class="c12"></span></p><p class="c0"><span class="c12"></span></p><h3 class="c25 c18" id="h.vr2e46f1e67n"><span class="c3">3. Optimize the neural network</span></h3><h2 class="c24 c18" id="h.2zl938xw6jfi"><span>The function optimize is implemented correctly. </span><span class="c9 c44">We compute the softmax cross entropy between logits and labels and use an Adam algorithm optimizer to minimize the cross entropy loss.</span><span class="c30 c43">An important point to note is, batch size and learning rate are linked. If the batch size is too small then the gradients will become more unstable and would need to reduce the learning rate.</span></h2><p class="c0"><span class="c30 c9 c44"></span></p><p class="c0"><span class="c30 c9 c44"></span></p><a id="t.37483edd5c864963827a6c5c12b6813bdded772a"></a><a id="t.3"></a><table class="c52 c18"><tbody><tr class="c36"><td class="c68" colspan="1" rowspan="1"><p class="c5 c18"><span class="c20"># Reshape logits for computing cross entropy</span></p><p class="c5 c18"><span class="c16">logits = tf.reshape(nn_last_layer</span><span class="c11">, </span><span class="c16">(-</span><span class="c33">1</span><span class="c11">, </span><span class="c16">num_classes)</span><span class="c11">, </span><span class="c13">name</span><span class="c16">=</span><span class="c17">&#39;logits&#39;</span><span class="c2">)</span></p><p class="c0"><span class="c2"></span></p><p class="c5 c18"><span class="c20"># Compute cross entropy and loss</span></p><p class="c5 c18"><span class="c16">cross_entropy_logits = tf.nn.softmax_cross_entropy_with_logits(</span><span class="c13">logits</span><span class="c16">=logits</span><span class="c11">, </span><span class="c13">labels</span><span class="c2">=correct_label)</span></p><p class="c0"><span class="c2"></span></p><p class="c5 c18"><span class="c20"># All regularization terms are added to a collection called tf.GraphKeys.REGULARIZATION_LOSSES,</span></p><p class="c5 c18"><span class="c20"># add the sum of all regularization losses to the previously calculated cross-entropy</span></p><p class="c5 c18"><span class="c16">cross_entropy_loss = tf.reduce_mean(cross_entropy_logits) + &nbsp;</span><span class="c45">sum</span><span class="c2">(tf.get_collection(tf.GraphKeys.REGULARIZATION_LOSSES))</span></p><p class="c0"><span class="c2"></span></p><p class="c5 c18"><span class="c20"># Training operation using the Adam optimizer</span></p><p class="c5 c18"><span class="c2">train_op = tf.train.AdamOptimizer(learning_rate).minimize(cross_entropy_loss)</span></p><p class="c0"><span class="c20"></span></p></td></tr></tbody></table><p class="c0"><span class="c30 c9 c44"></span></p><p class="c5 c40"><span class="c12"></span></p><h3 class="c25 c18" id="h.lzvx64ibazim"><span class="c3">3. Train the neural network</span></h3><p class="c0"><span class="c12"></span></p><a id="t.a03e8e1ef417be7deaabefa86e9ff11945261503"></a><a id="t.4"></a><table class="c52 c69"><tbody><tr class="c51"><td class="c57" colspan="1" rowspan="1"><p class="c41 c18"><span class="c12">Below you can see the loss decreasing </span></p></td><td class="c57" colspan="1" rowspan="2"><p class="c18 c26"><span class="c12"></span></p><p class="c5 c18"><span>The function train_nn is implemented correctly. The loss of the network is as shown below is printed while the network is training. On average, the model decreases loss over time. </span><span class="c9">In my case the optimal epoch I found with my model perform better using a batch size of 10 and loose was did not reduced after 100 epochs. </span></p><p class="c0"><span class="c12"></span></p></td></tr><tr class="c51"><td class="c57" colspan="1" rowspan="1"><p class="c5 c18"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 205.03px; height: 305.50px;"><img alt="" src="images/image7.png" style="width: 205.03px; height: 305.50px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p></td></tr></tbody></table><p class="c31"><span class="c12"></span></p><h3 class="c18 c25" id="h.50zbpz6dluhj"><span class="c3">4. Verify results</span></h3><p class="c5 c18"><span class="c12">The project labels most pixels of roads close to the best solution. The model doesn&#39;t have to predict correctly all the images, just most of them. As you can see in the images bellow this model is labeling more than 80% of the road and label no more than 20% of non-road pixels as road. </span></p><p class="c0"><span class="c12"></span></p><a id="t.34c968869fbbdaac8fff0fec79919d98042a1192"></a><a id="t.5"></a><table class="c52 c18"><tbody><tr class="c36"><td class="c32" colspan="1" rowspan="1"><p class="c41"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 373.00px; height: 104.00px;"><img alt="" src="images/image2.png" style="width: 373.00px; height: 104.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p></td><td class="c32" colspan="1" rowspan="1"><p class="c41"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 373.00px; height: 104.00px;"><img alt="" src="images/image10.png" style="width: 373.00px; height: 104.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p></td></tr><tr class="c36"><td class="c32" colspan="1" rowspan="1"><p class="c41"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 373.00px; height: 104.00px;"><img alt="" src="images/image3.png" style="width: 373.00px; height: 104.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p></td><td class="c32" colspan="1" rowspan="1"><p class="c41"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 373.00px; height: 104.00px;"><img alt="" src="images/image1.png" style="width: 373.00px; height: 104.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p></td></tr></tbody></table><p class="c0"><span class="c12"></span></p><p class="c0"><span class="c12"></span></p><hr><p class="c46 c18 c40"><span class="c34"></span></p><h2 class="c24" id="h.ns5pwmt1kxgq"><span class="c19">Update:</span></h2><p class="c5"><span class="c43">Semantic Segmentation has evolved quite a lot, since FCNs came by. I would highly recommend reading, </span><span class="c21"><a class="c8" href="https://www.google.com/url?q=http://blog.qure.ai/notes/semantic-segmentation-deep-learning-review&amp;sa=D&amp;ust=1522472818135000">Guide to Semantic Segmentation with Deep Learning</a></span><span class="c30 c43">, to explore how the solutions evolved since FCNs and the current state of the art used in real world problems.</span></p><p class="c1"><span class="c43">Do check out </span><span class="c39"><a class="c8" href="https://www.google.com/url?q=http://techtalks.tv/talks/fully-convolutional-networks-for-semantic-segmentation/61606/&amp;sa=D&amp;ust=1522472818136000">this talk</a></span><span class="c43">&nbsp;from authors of the original paper and also the </span><span class="c39"><a class="c8" href="https://www.google.com/url?q=https://people.eecs.berkeley.edu/~jonlong/long_shelhamer_fcn.pdf&amp;sa=D&amp;ust=1522472818136000">corresponding paper</a></span><span class="c30 c43">&nbsp;for more in depth details.</span></p><p class="c1"><span class="c43 c62">Further Experimentation</span><span class="c30 c43">: If you wish to work on a challenging dataset, you&#39;ll enjoy Cityscapes dataset. It has fine image annotations for 29 classes of objects. The images are video frames taken in German cities and there is around 11GB of them. This sample comes from the City Scapes dataset.</span></p><p class="c1"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 600.00px; height: 300.00px;"><img alt="" src="images/image4.png" style="width: 600.00px; height: 300.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><h2 class="c24 c18" id="h.kpumfxhu7sl8"><span class="c19">References:</span></h2><ul class="c50 lst-kix_a102oay53e4d-0 start"><li class="c5 c55"><span>Udacity Self-Driving Car <br>The link for the frozen VGG16 model is hardcoded into helper.py. The model can be found </span><span class="c23 c66"><a class="c8" href="https://www.google.com/url?q=https://s3-us-west-1.amazonaws.com/udacity-selfdrivingcar/vgg.zip&amp;sa=D&amp;ust=1522472818137000">here</a></span></li><li class="c5 c55"><span>The model is not vanilla VGG16, but a fully convolutional version, which already contains the 1x1 convolutions to replace the fully connected layers. </span><span class="c60">The pretrained VGG-16 model is already fully convolutionalized, i.e. it already contains the 1x1 convolutions that replace the fully connected layers.</span></li><li class="c5 c55"><span class="c12">When adding l2-regularization, setting a regularizer in the arguments of the tf.layers is not enough. Regularization loss terms must be manually added to your loss function. otherwise regularization is not implemented.</span></li></ul></body></html>