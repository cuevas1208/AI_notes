<html><head><meta content="text/html; charset=UTF-8" http-equiv="content-type"
</head><body class="c36 c40"><h1 class="c29" id="h.4x7mhf1lphco"><span class="c44 c1 c53">A* Search Algorithm</span></h1><h2 class="c22" id="h.edzewasqhh13"><span class="c1 c14">Intro:</span></h2><ol class="c34 lst-kix_yhbzk0mr0rox-0 start" start="1"><li class="c2 c37"><span class="c13">What is the easiest path to get to the goal destination in a map or game puzzle game?</span></li></ol><p class="c2 c7"><span class="c13"></span></p><p class="c2"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 624.00px; height: 330.67px;"><img alt="" src="images/image5.png" style="width: 624.00px; height: 330.67px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c2 c7"><span class="c13"></span></p><p class="c2"><span class="c1">A* Search Algorithm</span><span class="c13">&nbsp;is one of the best descrite technique used in path-finding and graph traversals.</span></p><h2 class="c22" id="h.pcxdvtp64q77"><span class="c14 c38">How it works?</span></h2><p class="c49 c46"><span>At each step it picks the node/cell with the lowest &lsquo;</span><span class="c1">f</span><span class="c13">&rsquo;.</span></p><p class="c49 c46"><span>&lsquo;</span><span class="c1">f</span><span>&rsquo; is is a parameter equal to the sum of &lsquo;</span><span class="c1">g</span><span>&rsquo; and &lsquo;</span><span class="c1">h</span><span class="c13">&rsquo;. </span></p><p class="c49 c46"><span class="c1">g</span><span class="c13">&nbsp;= the movement cost to move from the starting point to a given square on the grid, following the path generated to get there.</span></p><p class="c46 c49"><span class="c1">h</span><span>&nbsp;= the estimated movement cost/distance to the final destination. This is often referred to as the</span><span class="c1">&nbsp;heuristic</span><span class="c13">.</span></p><p class="c31"><span>&nbsp;</span><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 624.00px; height: 337.33px;"><img alt="" src="images/image3.png" style="width: 624.00px; height: 337.33px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><h2 class="c21" id="h.nc9nvpskr34f"><span class="c1 c4">Pseudocode</span><span class="c14 c1">&nbsp;Code:</span></h2><a id="t.32c6a27901b2f53daba7f03049ea475ef63c1bae"></a><a id="t.0"></a><table class="c0"><tbody><tr class="c42"><td class="c52" colspan="1" rowspan="1"><p class="c25"><span class="c23">// A* Search Algorithm<br></span><span class="c43 c38">1.</span><span class="c23">&nbsp; Initialize the open list<br></span><span class="c38 c43">2.</span><span class="c23">&nbsp; Initialize the closed list<br> &nbsp; &nbsp;put the starting node on the open <br> &nbsp; &nbsp;list (you can leave its f at zero)<br><br></span><span class="c43 c38">3.</span><span class="c23">&nbsp; </span><span class="c38 c41">while</span><span class="c23">&nbsp;the open list </span><span class="c41 c38">is</span><span class="c23">&nbsp;</span><span class="c41 c38">not</span><span class="c23">&nbsp;empty<br> &nbsp; &nbsp;a) find the node </span><span class="c41 c38">with</span><span class="c23">&nbsp;the least f on <br> &nbsp; &nbsp; &nbsp; the open list, call it </span><span class="c38 c48">&quot;q&quot;</span><span class="c23"><br><br> &nbsp; &nbsp;b) pop q off the open list<br> &nbsp;<br> &nbsp; &nbsp;c) generate q</span><span class="c48 c38">&#39;s 8 successors and set their <br> &nbsp; &nbsp; &nbsp; parents to q<br> &nbsp; <br> &nbsp; &nbsp;d) for each successor<br> &nbsp; &nbsp; &nbsp; &nbsp;i) if successor is the goal, stop search<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;successor.g = q.g + distance between <br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;successor and q<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;successor.h = distance from goal to <br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;successor (This can be done using many <br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;ways, we will discuss three heuristics- <br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Manhattan, Diagonal and Euclidean <br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Heuristics)<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;successor.f = successor.g + successor.h<br><br> &nbsp; &nbsp; &nbsp; &nbsp;ii) if a node with the same position as <br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;successor is in the OPEN list which has a <br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lower f than successor, skip this successor<br><br> &nbsp; &nbsp; &nbsp; &nbsp;iii) if a node with the same position as <br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;successor &nbsp;is in the CLOSED list which has<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;a lower f than successor, skip this successor<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;otherwise, add &nbsp;the node to the open list<br> &nbsp; &nbsp; end (for loop)<br> &nbsp;<br> &nbsp; &nbsp;e) push q on the closed list<br> &nbsp; &nbsp;end (while loop)</span></p></td></tr></tbody></table><p class="c28"><span class="c13">&nbsp;</span></p><p class="c28 c7"><span class="c26 c1"></span></p><h2 class="c22" id="h.77j56254e6ht"><span class="c1">How to calculate calculate heuristic</span><span class="c14 c38">&nbsp;(cost/distance to the final destination). </span></h2><h3 class="c11" id="h.glgqzkji50xu"><span class="c16">A) Exact Heuristics &ndash;</span></h3><p class="c28"><span class="c13">We can find exact values of h, but that is generally very time consuming. Below are some of the methods to calculate the exact value of h:</span></p><ul class="c34 lst-kix_z8qcvrca9jt9-0 start"><li class="c28 c37"><span class="c13">Pre-compute the distance between each pair of cells before running the A* Search Algorithm.</span></li><li class="c28 c37"><span>If there are no blocked cells/obstacles then we can just find the exact value of h without any pre-computation using the </span><span class="c33"><a class="c27" href="https://www.google.com/url?q=https://en.wikipedia.org/wiki/Euclidean_distance&amp;sa=D&amp;ust=1518400635603000&amp;usg=AFQjCNHm-dL3JXVqZtmzT1ZnHAV6Xr315A">distance formula/Euclidean Distance</a></span></li></ul><h3 class="c54" id="h.9epl0hu2trmw"><span class="c16">B) Approximation Heuristics Methods&ndash;</span></h3><p class="c28 c7"><span class="c26 c1"></span></p><a id="t.625e548793d717290cce1277e567ca9aa2cf0cfa"></a><a id="t.1"></a><table class="c0"><tbody><tr class="c30"><td class="c19" colspan="2" rowspan="1"><h2 class="c22 c46" id="h.wthfi0m0uzxb"><span class="c14 c38">1) Manhattan Distance</span></h2></td></tr><tr class="c39"><td class="c20" colspan="1" rowspan="1"><p class="c2"><span class="c13">Is the sum of absolute values of differences in the goal&rsquo;s x and y coordinates and the current cell&rsquo;s x and y coordinates respectively, i.e.,. &nbsp;Manhattan Distance can only be used when we are allowed to move only in four directions only (right, left, top, bottom)</span></p><p class="c2 c7"><span class="c13"></span></p><a id="t.c40d92273e50f02aefb41c34a18e97b620e1b1b2"></a><a id="t.2"></a><table class="c0"><tbody><tr class="c42"><td class="c15" colspan="1" rowspan="1"><p class="c25"><span class="c23">h = abs (current_cell.x - goal.x) &nbsp;+ &nbsp;abs (current_cell.y - goal.y)</span></p></td></tr></tbody></table><p class="c7 c32"><span class="c26 c1"></span></p></td><td class="c20" colspan="1" rowspan="1"><p class="c28"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 382.00px; height: 202.67px;"><img alt="" src="images/image4.png" style="width: 382.00px; height: 202.67px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p></td></tr></tbody></table><p class="c28 c7"><span class="c26 c1"></span></p><a id="t.0779d1ff33eb3625ed3539c104e8bd0b5a1cd453"></a><a id="t.3"></a><table class="c0"><tbody><tr class="c30"><td class="c19" colspan="2" rowspan="1"><h2 class="c22 c46" id="h.j4rez31kuemr"><span class="c14 c38">2) Diagonal Distance</span></h2></td></tr><tr class="c39"><td class="c20" colspan="1" rowspan="1"><p class="c2"><span class="c13">The maximum of absolute values of differences in the goal&rsquo;s x and y coordinates and the current cell&rsquo;s x and y coordinates respectively, i.e.,. </span></p><p class="c2"><span class="c13">Use case: When we are allowed to move in eight directions only (similar to a move of a King in Chess)</span></p><a id="t.657165aa9a2b6cbe80d5b3032b58ef898c3aecc8"></a><a id="t.4"></a><table class="c0"><tbody><tr class="c42"><td class="c15" colspan="1" rowspan="1"><p class="c32"><span class="c23">h = max { abs(current_cell.x - goal.x), &nbsp;abs(current_cell.y - goal.y) }</span></p></td></tr></tbody></table><p class="c2 c7"><span class="c13"></span></p></td><td class="c20" colspan="1" rowspan="1"><p class="c2"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 382.00px; height: 208.00px;"><img alt="Diagonal_Heuristics" src="images/image2.png" style="width: 382.00px; height: 208.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p></td></tr></tbody></table><p class="c7 c28"><span class="c26 c1"></span></p><a id="t.eb7225b3cb7ac983e886cb32f65bc80b5e5631ad"></a><a id="t.5"></a><table class="c0"><tbody><tr class="c30"><td class="c19" colspan="2" rowspan="1"><h3 class="c11 c46" id="h.w3znk26w4avv"><span class="c16">3) Euclidean Distance</span></h3></td></tr><tr class="c39"><td class="c20" colspan="1" rowspan="1"><p class="c2"><span class="c13">As it is clear from its name, it is nothing but the distance between the current cell and the goal cell using the distance formula. </span></p><p class="c2"><span class="c13">Use case: When we are allowed to move in any directions.</span></p><a id="t.15b568fb3ddda40da84a08e4cc2b97fa7810f62a"></a><a id="t.6"></a><table class="c0"><tbody><tr class="c42"><td class="c15" colspan="1" rowspan="1"><p class="c25"><span class="c23">h = sqrt ( (current_cell.x - goal.x)</span><span class="c43 c38">2</span><span class="c23">&nbsp;+ &nbsp;(current_cell.y - goal.y)</span><span class="c43 c38">2</span><span class="c23">&nbsp;)</span></p></td></tr></tbody></table><p class="c2 c7"><span class="c13"></span></p></td><td class="c20" colspan="1" rowspan="1"><p class="c2"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 382.00px; height: 208.00px;"><img alt="Euclidean_Heuristics" src="images/image1.png" style="width: 382.00px; height: 208.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p></td></tr></tbody></table><p class="c28 c7"><span class="c1 c26"></span></p><h1 class="c47" id="h.w34g9bu8fadn"><span class="c44 c4 c1">Hybrid A* Pseudocode:</span></h1><p class="c46 c50"><span class="c44 c45 c38 c10">The following variables and objects are used in the code bellow:</span></p><ul class="c34 lst-kix_kgftrmlk3obq-0 start"><li class="c5"><span class="c24">State(x, y, theta, g, f)</span><span class="c12 c10">: An object which stores </span><span class="c24">x</span><span class="c10 c12">, </span><span class="c24">y</span><span class="c12 c10">&nbsp;coordinates, direction </span><span class="c24">theta</span><span class="c12 c10">, and current </span><span class="c24">g</span><span class="c12 c10">&nbsp;and </span><span class="c24">f </span><span class="c44 c12 c38 c10">values. grid: A 2D array of 0s and 1s indicating the area to be searched. 1s correspond to obstacles, and 0s correspond to free space.</span></li><li class="c5"><span class="c24">SPEED</span><span class="c44 c12 c38 c10">: The speed of the vehicle used in the bicycle model.</span></li><li class="c5"><span class="c24">LENGTH</span><span class="c12 c38 c10 c44">: The length of the vehicle used in the bicycle model.</span></li><li class="c5"><span class="c24">NUM_THETA_CELLS</span><span class="c12 c10">: The number of cells a circle is divided into. This is used in keeping track of which States we have visited already.</span></li></ul><p class="c50 c46"><span class="c10">The </span><span class="c24">search</span><span class="c44 c45 c38 c10">&nbsp;function contains the bulk of the hybrid A* algorithm</span></p><p class="c50 c46"><span class="c10">The </span><span class="c24">expand</span><span class="c44 c45 c38 c10">&nbsp;function takes a state and goal as inputs and returns a list of possible next states for a range of steering angles. </span></p><a id="t.166f3745e732b2bebf20a231b5a007d7dbef50c4"></a><a id="t.7"></a><table class="c0"><tbody><tr class="c42"><td class="c52" colspan="1" rowspan="1"><p class="c25"><span class="c3">def</span><span class="c8">&nbsp;expand</span><span class="c35">(state, goal)</span><span class="c8">:<br> &nbsp; &nbsp;next_states = []<br> &nbsp; &nbsp;</span><span class="c3">for</span><span class="c8">&nbsp;delta </span><span class="c3">in</span><span class="c8">&nbsp;range(</span><span class="c9">-35</span><span class="c8">, </span><span class="c9">40</span><span class="c8">, </span><span class="c9">5</span><span class="c8">): <br> &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c6"># Create a trajectory with delta as the steering angle using the bicycle model:</span><span class="c8"><br><br> &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c6"># ---Begin bicycle model---</span><span class="c8"><br> &nbsp; &nbsp; &nbsp; &nbsp;delta_rad = deg_to_rad(delta)<br> &nbsp; &nbsp; &nbsp; &nbsp;omega = SPEED/LENGTH * tan(delta_rad)<br> &nbsp; &nbsp; &nbsp; &nbsp;next_x = state.x + SPEED * cos(theta)<br> &nbsp; &nbsp; &nbsp; &nbsp;next_y = state.y + SPEED * sin(theta)<br> &nbsp; &nbsp; &nbsp; &nbsp;next_theta = normalize(state.theta + omega)<br> &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c6"># ---End bicycle model-----</span><span class="c8"><br><br> &nbsp; &nbsp; &nbsp; &nbsp;next_g = state.g + </span><span class="c9">1</span><span class="c8"><br> &nbsp; &nbsp; &nbsp; &nbsp;next_f = next_g + heuristic(next_x, next_y, goal)<br><br> &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c6"># Create a new State object with all of the &quot;next&quot; values.</span><span class="c8"><br> &nbsp; &nbsp; &nbsp; &nbsp;state = State(next_x, next_y, next_theta, next_g, next_f)<br> &nbsp; &nbsp; &nbsp; &nbsp;next_states.append(state)<br><br> &nbsp; &nbsp;</span><span class="c3">return</span><span class="c8">&nbsp;next_states<br><br></span><span class="c3">def</span><span class="c8">&nbsp;search</span><span class="c35">(grid, start, goal)</span><span class="c8">:<br> &nbsp; &nbsp;</span><span class="c6"># The opened array keeps track of the stack of States objects we are </span><span class="c8"><br> &nbsp; &nbsp;</span><span class="c6"># searching through.</span><span class="c8"><br> &nbsp; &nbsp;opened = []<br> &nbsp; &nbsp;</span><span class="c6"># 3D array of zeros with dimensions:</span><span class="c8"><br> &nbsp; &nbsp;</span><span class="c6"># (NUM_THETA_CELLS, grid x size, grid y size).</span><span class="c8"><br> &nbsp; &nbsp;closed = [[[</span><span class="c9">0</span><span class="c8">&nbsp;</span><span class="c3">for</span><span class="c8">&nbsp;x </span><span class="c3">in</span><span class="c8">&nbsp;range(grid[</span><span class="c9">0</span><span class="c8">])] </span><span class="c3">for</span><span class="c8">&nbsp;y </span><span class="c3">in</span><span class="c8">&nbsp;range(len(grid))] </span><span class="c3">for</span><span class="c8">&nbsp;cell </span><span class="c3">in</span><span class="c8">&nbsp;range(NUM_THETA_CELLS)]<br> &nbsp; &nbsp;</span><span class="c6"># 3D array with same dimensions. Will be filled with State() objects to keep </span><span class="c8"><br> &nbsp; &nbsp;</span><span class="c6"># track of the path through the grid. </span><span class="c8"><br> &nbsp; &nbsp;came_from = [[[</span><span class="c9">0</span><span class="c8">&nbsp;</span><span class="c3">for</span><span class="c8">&nbsp;x </span><span class="c3">in</span><span class="c8">&nbsp;range(grid[</span><span class="c9">0</span><span class="c8">])] </span><span class="c3">for</span><span class="c8">&nbsp;y </span><span class="c3">in</span><span class="c8">&nbsp;range(len(grid))] </span><span class="c3">for</span><span class="c8">&nbsp;cell </span><span class="c3">in</span><span class="c8">&nbsp;range(NUM_THETA_CELLS)]<br><br> &nbsp; &nbsp;</span><span class="c6"># Create new state object to start the search with.</span><span class="c8"><br> &nbsp; &nbsp;x = start.x<br> &nbsp; &nbsp;y = start.y<br> &nbsp; &nbsp;theta = start.theta<br> &nbsp; &nbsp;g = </span><span class="c9">0</span><span class="c8"><br> &nbsp; &nbsp;f = heuristic(start.x, start.y, goal)<br> &nbsp; &nbsp;state = State(x, y, theta, </span><span class="c9">0</span><span class="c8">, f)<br> &nbsp; &nbsp;opened.append(state)<br><br> &nbsp; &nbsp;</span><span class="c6"># The range from 0 to 2pi has been discretized into NUM_THETA_CELLS cells. </span><span class="c8"><br> &nbsp; &nbsp;</span><span class="c6"># Here, theta_to_stack_number returns the cell that theta belongs to. </span><span class="c8"><br> &nbsp; &nbsp;</span><span class="c6"># Smaller thetas (close to 0 when normalized &nbsp;into the range from 0 to 2pi) </span><span class="c8"><br> &nbsp; &nbsp;</span><span class="c6"># have lower stack numbers, and larger thetas (close to 2pi when normalized)</span><span class="c8"><br> &nbsp; &nbsp;</span><span class="c6"># have larger stack numbers.</span><span class="c8"><br> &nbsp; &nbsp;stack_number = theta_to_stack_number(state.theta)<br> &nbsp; &nbsp;closed[stack_number][index(state.x)][index(state.y)] = </span><span class="c9">1</span><span class="c8"><br><br> &nbsp; &nbsp;</span><span class="c6"># Store our starting state. For other states, we will store the previous state </span><span class="c8"><br> &nbsp; &nbsp;</span><span class="c6"># in the path, but the starting state has no previous.</span><span class="c8"><br> &nbsp; &nbsp;came_from[stack_number][index(state.x)][index(state.y)] = state<br><br> &nbsp; &nbsp;</span><span class="c6"># While there are still states to explore:</span><span class="c8"><br> &nbsp; &nbsp;</span><span class="c3">while</span><span class="c8">&nbsp;opened:<br> &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c6"># Sort the states by f-value and start search using the state with the </span><span class="c8"><br> &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c6"># lowest f-value. This is crucial to the A* algorithm; the f-value </span><span class="c8"><br> &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c6"># improves search efficiency by indicating where to look first.</span><span class="c8"><br> &nbsp; &nbsp; &nbsp; &nbsp;opened.sort(key=</span><span class="c3">lambda</span><span class="c8">&nbsp;state:state.f)<br> &nbsp; &nbsp; &nbsp; &nbsp;current = opened.pop(</span><span class="c9">0</span><span class="c8">)<br><br> &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c6"># Check if the x and y coordinates are in the same grid cell as the goal. </span><span class="c8"><br> &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c6"># (Note: The idx function returns the grid index for a given coordinate.)</span><span class="c8"><br> &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c3">if</span><span class="c8">&nbsp;(idx(current.x) == goal[</span><span class="c9">0</span><span class="c8">]) </span><span class="c3">and</span><span class="c8">&nbsp;(idx(current.y) == goal.y):<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c6"># If so, the trajectory has reached the goal.</span><span class="c8"><br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c3">return</span><span class="c8">&nbsp;path<br><br> &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c6"># Otherwise, expand the current state to get a list of possible next states.</span><span class="c8"><br> &nbsp; &nbsp; &nbsp; &nbsp;next_states = expand(current, goal)<br> &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c3">for</span><span class="c8">&nbsp;next_state </span><span class="c3">in</span><span class="c8">&nbsp;next_states:<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c6"># If we have expanded outside the grid, skip this next_state.</span><span class="c8"><br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c3">if</span><span class="c8">&nbsp;next_states </span><span class="c3">is</span><span class="c8">&nbsp;</span><span class="c3">not</span><span class="c8">&nbsp;</span><span class="c3">in</span><span class="c8">&nbsp;the grid:<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c3">continue</span><span class="c8"><br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c6"># Otherwise, check that we haven&#39;t already visited this cell and</span><span class="c8"><br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c6"># that there is not an obstacle in the grid there.</span><span class="c8"><br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;stack_number = theta_to_stack_number(next_state.theta)<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c3">if</span><span class="c8">&nbsp;closed_value[stack_number][idx(next_state.x)][idx(next_state.y)] == </span><span class="c9">0</span><span class="c8">&nbsp;</span><span class="c3">and</span><span class="c8">&nbsp;grid[idx(next_state.x)][idx(next_state.y)] == </span><span class="c9">0</span><span class="c8">:<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c6"># The state can be added to the opened stack.</span><span class="c8"><br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;opened.append(next_state)<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c6"># The stack_number, idx(next_state.x), idx(next_state.y) tuple </span><span class="c8"><br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c6"># has now been visited, so it can be closed.</span><span class="c8"><br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;closed[stack_number][idx(next_state.x)][idx(next_state.y)] = </span><span class="c9">1</span><span class="c8"><br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c6"># The next_state came from the current state, and that is recorded.</span><span class="c8"><br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;came_from[stack_number][idx(next_state.x)][idx(next_state.y)] = current</span></p></td></tr></tbody></table><p class="c2 c7"><span class="c13"></span></p><h3 class="c11" id="h.tfuv1fbsza1s"><span class="c16">Reference :</span></h3><p class="c2"><span class="c13">Udacity Self-Driving Car </span></p><p class="c2"><span class="c17"><a class="c27" href="https://www.google.com/url?q=https://www.geeksforgeeks.org/a-search-algorithm/&amp;sa=D&amp;ust=1518400635616000&amp;usg=AFQjCNEgJ__Q0eXVfJCrHOPP8F_RuGQvjw">geeksforgeeks</a></span></p><p class="c2"><span class="c17"><a class="c27" href="https://www.google.com/url?q=https://d17h27t6h515a5.cloudfront.net/topher/2017/July/595fe838_junior-the-stanford-entry-in-the-urban-challenge/junior-the-stanford-entry-in-the-urban-challenge.pdf&amp;sa=D&amp;ust=1518400635617000&amp;usg=AFQjCNEt7J6kRYoiC8uIzg4cCAJuB2cwxQ">Junior: The Stanford Entry in the Urban Challenge</a></span></p></body></html>